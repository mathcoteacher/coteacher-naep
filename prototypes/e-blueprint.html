<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>E â€” Blueprint</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #0a1628; color: #e8e2d4;
    display: flex; flex-direction: column; align-items: center;
    min-height: 100vh; padding: 1.5rem;
  }
  .header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }
  .header h1 { font-size: 1.3rem; font-weight: 600; }
  .back { color: #e8e2d4; text-decoration: none; font-size: 0.85rem; opacity: 0.5; }
  .back:hover { opacity: 1; }
  canvas { max-width: 100%; }
  .controls { margin-top: 1rem; }
  button {
    background: transparent; color: #e8e2d4; border: 1px solid rgba(232, 226, 212, 0.3); border-radius: 4px;
    padding: 0.45rem 1.2rem; font-size: 0.85rem; cursor: pointer;
  }
  button:hover { border-color: #e8e2d4; }
  .message {
    margin-top: 1.5rem; text-align: center; max-width: 600px;
    opacity: 0; transition: opacity 0.8s;
  }
  .message.visible { opacity: 1; }
  .headline {
    font-size: clamp(1.5rem, 5vw, 2.4rem); font-weight: 800;
    line-height: 1.15; color: #e8e2d4; letter-spacing: -0.02em;
  }
  .headline .num { color: #c9a84c; }
  .subline {
    margin-top: 0.6rem; font-size: clamp(0.85rem, 2.5vw, 1.05rem);
    color: #6a7a8c; line-height: 1.5;
  }
</style>
</head>
<body>
<div class="header">
  <a class="back" href="index-v2.html">&larr; Back</a>
  <h1>E. Blueprint</h1>
</div>
<canvas id="c"></canvas>
<div class="controls"><button id="replay">Replay</button></div>
<div class="message" id="msg">
  <div class="headline"><span class="num">7</span> out of <span class="num">10</span> Ohio 8th graders are below proficient in math.</div>
  <div class="subline">They are deep down a road of a lifetime of lost potential.</div>
</div>

<script>
const ACCENT = '#e8e2d4';
const ACCENT_NUM = '#c9a84c';
const DEAD = '#1e3a5f';
const BG = '#0a1628';

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const msg = document.getElementById('msg');

let W, H, FW, FH, GAP, SX, SY;

function sizing() {
  const maxW = Math.min(window.innerWidth - 40, 700);
  W = maxW; H = Math.round(maxW * 0.55);
  canvas.width = W; canvas.height = H;
  FW = Math.round(W * 0.055); FH = Math.round(FW * 2.6);
  GAP = Math.round((W - FW * 10) / 11); SX = GAP;
  SY = Math.round((H - FH) / 2) + 10;
}

function drawFigure(x, y, w, h, color, alpha) {
  ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = color;
  const headR = w * 0.42, cx = x + w / 2, cy = y + headR;
  ctx.beginPath(); ctx.arc(cx, cy, headR, 0, Math.PI * 2); ctx.fill();
  const bt = cy + headR + h * 0.04, bb = y + h, bw = w * 0.85, bx = x + (w - bw) / 2;
  ctx.beginPath();
  ctx.moveTo(bx + bw * 0.15, bt); ctx.lineTo(bx + bw * 0.85, bt);
  ctx.quadraticCurveTo(bx + bw, bt, bx + bw, bt + (bb - bt) * 0.15);
  ctx.lineTo(bx + bw, bb - 6); ctx.quadraticCurveTo(bx + bw, bb, bx + bw - 6, bb);
  ctx.lineTo(bx + 6, bb); ctx.quadraticCurveTo(bx, bb, bx, bb - 6);
  ctx.lineTo(bx, bt + (bb - bt) * 0.15); ctx.quadraticCurveTo(bx, bt, bx + bw * 0.15, bt);
  ctx.fill(); ctx.restore();
}

function drawGlowingFigure(x, y, w, h, color, alpha, glowRadius) {
  if (glowRadius > 0 && alpha > 0.1) {
    ctx.save(); ctx.globalAlpha = alpha * 0.2;
    ctx.shadowColor = color; ctx.shadowBlur = glowRadius;
    drawFigure(x, y, w, h, color, 1); ctx.restore();
  }
  drawFigure(x, y, w, h, color, alpha);
}

function buildFormingPixels(fi) {
  const fx = SX + fi * (FW + GAP);
  const pSize = Math.max(2, FW * 0.12);
  const cols = Math.ceil(FW / pSize), rows = Math.ceil(FH / pSize);
  const off = document.createElement('canvas');
  off.width = FW + 4; off.height = FH + 4;
  const oc = off.getContext('2d');
  oc.fillStyle = ACCENT;
  const headR = FW * 0.42, cx = 2 + FW / 2, cy = 2 + headR;
  oc.beginPath(); oc.arc(cx, cy, headR, 0, Math.PI * 2); oc.fill();
  const bt = cy + headR + FH * 0.04, bb = 2 + FH, bw = FW * 0.85, bx = 2 + (FW - bw) / 2;
  oc.beginPath();
  oc.moveTo(bx + bw * 0.15, bt); oc.lineTo(bx + bw * 0.85, bt);
  oc.quadraticCurveTo(bx + bw, bt, bx + bw, bt + (bb - bt) * 0.15);
  oc.lineTo(bx + bw, bb - 6); oc.quadraticCurveTo(bx + bw, bb, bx + bw - 6, bb);
  oc.lineTo(bx + 6, bb); oc.quadraticCurveTo(bx, bb, bx, bb - 6);
  oc.lineTo(bx, bt + (bb - bt) * 0.15); oc.quadraticCurveTo(bx, bt, bx + bw * 0.15, bt);
  oc.fill();
  const imgD = oc.getImageData(0, 0, off.width, off.height);
  const pixels = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const px = Math.round(c * pSize + pSize / 2) + 2, py = Math.round(r * pSize + pSize / 2) + 2;
      if (px < imgD.width && py < imgD.height && imgD.data[(py * imgD.width + px) * 4 + 3] > 128) {
        pixels.push({ tx: fx + c * pSize, ty: SY + r * pSize,
          x: fx + c * pSize + (Math.random() - 0.5) * W * 0.5,
          y: SY + r * pSize + (Math.random() - 0.5) * H * 0.8, size: pSize });
      }
    }
  }
  return pixels;
}

const flickerOrder = [3, 0, 5, 1, 6, 4, 2];
const flickerDuration = 0.25, flickerGap = 0.22;
let formingPixels = [], startTime = 0, animFrame, textShown = false;
function ease(t) { return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; }

function init() {
  sizing(); msg.classList.remove('visible'); msg.style.opacity = '0'; textShown = false;
  formingPixels = [];
  for (let i = 0; i < 10; i++) formingPixels.push(buildFormingPixels(i));
  startTime = performance.now();
  if (animFrame) cancelAnimationFrame(animFrame); animate();
}

function animate() {
  const elapsed = (performance.now() - startTime) / 1000;
  ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);

  if (elapsed < 1.5) {
    const t = ease(Math.min(elapsed / 1.5, 1));
    for (let i = 0; i < 10; i++) {
      for (const p of formingPixels[i]) {
        ctx.globalAlpha = 0.3 + 0.7 * t; ctx.fillStyle = ACCENT;
        ctx.fillRect(p.x + (p.tx - p.x) * t, p.y + (p.ty - p.y) * t, p.size, p.size);
      }
    }
    ctx.globalAlpha = 1;
  } else if (elapsed < 2.0) {
    for (let i = 0; i < 10; i++) {
      const pulse = 0.92 + 0.08 * Math.sin(elapsed * 3 + i * 0.7);
      drawGlowingFigure(SX + i * (FW + GAP), SY, FW, FH, ACCENT, pulse, 8);
    }
  } else if (elapsed < 4.0) {
    const dt = elapsed - 2.0;
    const figureState = new Array(10).fill(1);
    for (let k = 0; k < flickerOrder.length; k++) {
      const fi = flickerOrder[k], localT = (dt - k * flickerGap) / flickerDuration;
      if (localT >= 0 && localT < 1) figureState[fi] = Math.sin(localT * Math.PI * 8) * 0.5 * (1 - ease(localT)) + 0.5 * (1 - ease(localT));
      else if (localT >= 1) figureState[fi] = 0;
    }
    for (let i = 0; i < 10; i++) {
      const fx = SX + i * (FW + GAP);
      if (i >= 7) { drawGlowingFigure(fx, SY, FW, FH, ACCENT, 0.92 + 0.08 * Math.sin(elapsed * 3 + i * 0.7), 8); }
      else {
        const s = figureState[i];
        if (s <= 0) drawFigure(fx, SY, FW, FH, DEAD, 0.6);
        else if (s >= 0.95) drawGlowingFigure(fx, SY, FW, FH, ACCENT, 0.95, 8);
        else drawGlowingFigure(fx, SY, FW, FH, ACCENT, s, s * 10);
      }
    }
  } else {
    for (let i = 0; i < 7; i++) drawFigure(SX + i * (FW + GAP), SY, FW, FH, DEAD, 0.6);
    for (let i = 7; i < 10; i++) drawGlowingFigure(SX + i * (FW + GAP), SY, FW, FH, ACCENT, 0.92 + 0.08 * Math.sin(elapsed * 3 + i * 0.7), 8);
    if (elapsed > 4.3 && !textShown) { textShown = true; msg.style.opacity = ''; void msg.offsetHeight; msg.classList.add('visible'); }
  }
  animFrame = requestAnimationFrame(animate);
}

document.getElementById('replay').addEventListener('click', init);
window.addEventListener('resize', init);
init();
</script>
</body>
</html>
