<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>A â€” Newsprint</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Georgia', 'Times New Roman', serif;
    background: #f4f1eb; color: #1a1a1a;
    display: flex; flex-direction: column; align-items: center;
    min-height: 100vh; padding: 1.5rem;
  }
  @media (prefers-color-scheme: dark) {
    body { background: #1a1912; color: #d8d4ca; }
  }
  .header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }
  .header h1 { font-size: 1.3rem; font-weight: 700; letter-spacing: -0.02em; }
  .back { color: #1a1a1a; text-decoration: none; font-size: 0.85rem; opacity: 0.5; }
  .back:hover { opacity: 1; }
  canvas { max-width: 100%; }
  .controls { margin-top: 1rem; }
  button {
    background: #1a1a1a; color: #f4f1eb; border: none; border-radius: 2px;
    padding: 0.45rem 1.2rem; font-size: 0.85rem; cursor: pointer;
    font-family: inherit; letter-spacing: 0.05em; text-transform: uppercase;
  }
  button:hover { background: #333; }
  @media (prefers-color-scheme: dark) {
    button { background: #d8d4ca; color: #1a1912; }
    button:hover { background: #bbb5a8; }
    .back { color: #d8d4ca; }
  }
  .message {
    margin-top: 1.5rem; text-align: center; max-width: 600px;
    opacity: 0; transition: opacity 0.8s;
  }
  .message.visible { opacity: 1; }
  .headline {
    font-size: clamp(1.5rem, 5vw, 2.4rem); font-weight: 900;
    line-height: 1.15; color: #1a1a1a; letter-spacing: -0.03em;
    font-style: italic;
  }
  .headline .num { color: #c41e1e; font-style: normal; }
  .subline {
    margin-top: 0.6rem; font-size: clamp(0.85rem, 2.5vw, 1.05rem);
    color: #555; line-height: 1.5; font-style: italic;
  }
  @media (prefers-color-scheme: dark) {
    .headline { color: #d8d4ca; }
    .headline .num { color: #e05a4a; }
    .subline { color: #8a8578; }
  }
</style>
</head>
<body>
<div class="header">
  <a class="back" href="index-v2.html">&larr; Back</a>
  <h1>A. Newsprint</h1>
</div>
<canvas id="c"></canvas>
<div class="controls"><button id="replay">Replay</button></div>
<div class="message" id="msg">
  <div class="headline"><span class="num">7</span> out of <span class="num">10</span> Ohio 8th graders are below proficient in math.</div>
  <div class="subline">They are deep down a road of a lifetime of lost potential.</div>
</div>

<script>
const ACCENT = '#1a1a1a';
const ACCENT_GLOW = '#1a1a1a';
const DEAD_LIGHT = '#c8c3b8';
const DEAD_DARK = '#3a3830';
const BG_LIGHT = '#f4f1eb';
const BG_DARK = '#1a1912';
let isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const msg = document.getElementById('msg');

let W, H, FW, FH, GAP, SX, SY;

function sizing() {
  const maxW = Math.min(window.innerWidth - 40, 700);
  W = maxW; H = Math.round(maxW * 0.55);
  canvas.width = W; canvas.height = H;
  FW = Math.round(W * 0.055);
  FH = Math.round(FW * 2.6);
  GAP = Math.round((W - FW * 10) / 11);
  SX = GAP;
  SY = Math.round((H - FH) / 2) + 10;
}

function drawFigure(x, y, w, h, color, alpha) {
  ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = color;
  const headR = w * 0.42, cx = x + w / 2, cy = y + headR;
  ctx.beginPath(); ctx.arc(cx, cy, headR, 0, Math.PI * 2); ctx.fill();
  const bt = cy + headR + h * 0.04, bb = y + h, bw = w * 0.85, bx = x + (w - bw) / 2;
  ctx.beginPath();
  ctx.moveTo(bx + bw * 0.15, bt); ctx.lineTo(bx + bw * 0.85, bt);
  ctx.quadraticCurveTo(bx + bw, bt, bx + bw, bt + (bb - bt) * 0.15);
  ctx.lineTo(bx + bw, bb - 6); ctx.quadraticCurveTo(bx + bw, bb, bx + bw - 6, bb);
  ctx.lineTo(bx + 6, bb); ctx.quadraticCurveTo(bx, bb, bx, bb - 6);
  ctx.lineTo(bx, bt + (bb - bt) * 0.15); ctx.quadraticCurveTo(bx, bt, bx + bw * 0.15, bt);
  ctx.fill(); ctx.restore();
}

function drawGlowingFigure(x, y, w, h, color, alpha, glowRadius) {
  if (glowRadius > 0 && alpha > 0.1) {
    ctx.save(); ctx.globalAlpha = alpha * 0.15;
    ctx.shadowColor = color; ctx.shadowBlur = glowRadius;
    drawFigure(x, y, w, h, color, 1); ctx.restore();
  }
  drawFigure(x, y, w, h, color, alpha);
}

function buildFormingPixels(fi) {
  const fx = SX + fi * (FW + GAP);
  const pSize = Math.max(2, FW * 0.12);
  const cols = Math.ceil(FW / pSize), rows = Math.ceil(FH / pSize);
  const off = document.createElement('canvas');
  off.width = FW + 4; off.height = FH + 4;
  const oc = off.getContext('2d');
  oc.fillStyle = ACCENT;
  const headR = FW * 0.42, cx = 2 + FW / 2, cy = 2 + headR;
  oc.beginPath(); oc.arc(cx, cy, headR, 0, Math.PI * 2); oc.fill();
  const bt = cy + headR + FH * 0.04, bb = 2 + FH, bw = FW * 0.85, bx = 2 + (FW - bw) / 2;
  oc.beginPath();
  oc.moveTo(bx + bw * 0.15, bt); oc.lineTo(bx + bw * 0.85, bt);
  oc.quadraticCurveTo(bx + bw, bt, bx + bw, bt + (bb - bt) * 0.15);
  oc.lineTo(bx + bw, bb - 6); oc.quadraticCurveTo(bx + bw, bb, bx + bw - 6, bb);
  oc.lineTo(bx + 6, bb); oc.quadraticCurveTo(bx, bb, bx, bb - 6);
  oc.lineTo(bx, bt + (bb - bt) * 0.15); oc.quadraticCurveTo(bx, bt, bx + bw * 0.15, bt);
  oc.fill();
  const imgD = oc.getImageData(0, 0, off.width, off.height);
  const pixels = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const px = Math.round(c * pSize + pSize / 2) + 2;
      const py = Math.round(r * pSize + pSize / 2) + 2;
      if (px < imgD.width && py < imgD.height) {
        const idx = (py * imgD.width + px) * 4;
        if (imgD.data[idx + 3] > 128) {
          pixels.push({
            tx: fx + c * pSize, ty: SY + r * pSize,
            x: fx + c * pSize + (Math.random() - 0.5) * W * 0.5,
            y: SY + r * pSize + (Math.random() - 0.5) * H * 0.8,
            size: pSize
          });
        }
      }
    }
  }
  return pixels;
}

const flickerOrder = [3, 0, 5, 1, 6, 4, 2];
const flickerDuration = 0.25;
const flickerGap = 0.22;

let formingPixels = [];
let startTime = 0;
let animFrame;
let textShown = false;

function ease(t) { return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; }

function init() {
  sizing(); msg.classList.remove('visible'); msg.style.opacity = '0'; textShown = false;
  formingPixels = [];
  for (let i = 0; i < 10; i++) formingPixels.push(buildFormingPixels(i));
  startTime = performance.now();
  if (animFrame) cancelAnimationFrame(animFrame);
  animate();
}

function animate() {
  const elapsed = (performance.now() - startTime) / 1000;
  const bg = isDark ? BG_DARK : BG_LIGHT;
  ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);
  const accentColor = isDark ? '#d8d4ca' : ACCENT;

  if (elapsed < 1.5) {
    const t = ease(Math.min(elapsed / 1.5, 1));
    for (let i = 0; i < 10; i++) {
      for (const p of formingPixels[i]) {
        const cx = p.x + (p.tx - p.x) * t;
        const cy = p.y + (p.ty - p.y) * t;
        ctx.globalAlpha = 0.3 + 0.7 * t;
        ctx.fillStyle = accentColor;
        ctx.fillRect(cx, cy, p.size, p.size);
      }
    }
    ctx.globalAlpha = 1;
  } else if (elapsed < 2.0) {
    for (let i = 0; i < 10; i++) {
      const fx = SX + i * (FW + GAP);
      const pulse = 0.92 + 0.08 * Math.sin(elapsed * 3 + i * 0.7);
      drawGlowingFigure(fx, SY, FW, FH, accentColor, pulse, 4);
    }
  } else if (elapsed < 4.0) {
    const dt = elapsed - 2.0;
    const figureState = new Array(10).fill(1);
    for (let k = 0; k < flickerOrder.length; k++) {
      const fi = flickerOrder[k];
      const flickerStart = k * flickerGap;
      const localT = (dt - flickerStart) / flickerDuration;
      if (localT < 0) figureState[fi] = 1;
      else if (localT < 1) { figureState[fi] = Math.sin(localT * Math.PI * 8) * 0.5 * (1 - ease(localT)) + 0.5 * (1 - ease(localT)); }
      else figureState[fi] = 0;
    }
    for (let i = 0; i < 10; i++) {
      const fx = SX + i * (FW + GAP);
      if (i >= 7) {
        const pulse = 0.92 + 0.08 * Math.sin(elapsed * 3 + i * 0.7);
        drawGlowingFigure(fx, SY, FW, FH, accentColor, pulse, 4);
      } else {
        const state = figureState[i];
        if (state <= 0) { drawFigure(fx, SY, FW, FH, isDark ? DEAD_DARK : DEAD_LIGHT, 0.5); }
        else if (state >= 0.95) { drawGlowingFigure(fx, SY, FW, FH, accentColor, 0.95, 4); }
        else { drawGlowingFigure(fx, SY, FW, FH, accentColor, state, state * 6); }
      }
    }
  } else {
    for (let i = 0; i < 7; i++) { drawFigure(SX + i * (FW + GAP), SY, FW, FH, isDark ? DEAD_DARK : DEAD_LIGHT, 0.5); }
    for (let i = 7; i < 10; i++) {
      const pulse = 0.92 + 0.08 * Math.sin(elapsed * 3 + i * 0.7);
      drawGlowingFigure(SX + i * (FW + GAP), SY, FW, FH, accentColor, pulse, 4);
    }
    if (elapsed > 4.3 && !textShown) {
      textShown = true; msg.style.opacity = ''; void msg.offsetHeight; msg.classList.add('visible');
    }
  }
  animFrame = requestAnimationFrame(animate);
}

document.getElementById('replay').addEventListener('click', init);
window.addEventListener('resize', init);
init();
</script>
</body>
</html>
